--- odes_ida.py	(original)
+++ odes_ida.py	(refactored)
@@ -106,14 +106,14 @@
     from pysundials import ida
     from pysundials import nvecserial
 except:
-    print "Warning: ida solver not available, pysundials needed"
+    print("Warning: ida solver not available, pysundials needed")
     raise ImportError
 
 from numpy import isscalar
 import re
 import ctypes
 
-import dae
+from . import dae
 
 class odesIDA(dae.DaeIntegratorBase):
     __doc__ = integrator_info_ida
@@ -140,8 +140,8 @@
                  out = False
                  ):
         if not  isscalar(rtol) :
-            raise ValueError,'rtol (%s) must be a scalar for IDA'\
-                        % (rtol)
+            raise ValueError('rtol (%s) must be a scalar for IDA'\
+                        % (rtol))
         self.rtol = rtol
         if not isscalar(atol) : 
             self.atol = nvecserial.NVector(list(atol))
@@ -152,14 +152,14 @@
 
         self.tcrit = tcrit
         if order > 5 or order < 1:
-            raise ValueError, 'order should be >=1, <=5'
+            raise ValueError('order should be >=1, <=5')
         self.order = order
         self.nsteps = nsteps
         self.max_step = max_step
         self.first_step = first_step
         if constraints and constraint_type is None:
-            raise ValueError, 'Give type of contraint as '\
-                              'an array (1:>=0, 2:>0, -1:<=0, -2:<0)'
+            raise ValueError('Give type of contraint as '\
+                              'an array (1:>=0, 2:>0, -1:<=0, -2:<0)')
         elif constraints:
             self.constraint_type = nvecserial.NVector(list(constraint_type))
         else:
@@ -168,13 +168,13 @@
         elif re.match(compute_initcond,r'yprime0',re.I): 
             self.compute_initcond = 2
         elif re.match(compute_initcond,r'yode0',re.I): self.compute_initcond = 1
-        else: raise ValueError,'Unknown init cond calculation method %s' %(
-                                                            compute_initcond)
+        else: raise ValueError('Unknown init cond calculation method %s' %(
+                                                            compute_initcond))
         self.compute_initcond_t0 = compute_initcond_t0
         if self.compute_initcond == 1 and algebraic_var is None:
-            raise ValueError, 'Give integer array indicating which are the '\
+            raise ValueError('Give integer array indicating which are the '\
                               'algebraic variables, +1 for diffential var, '\
-                              '-1 for algebraic var'
+                              '-1 for algebraic var')
         #alg var in IDA is <=0 (officially 0) , differential var > 0 (off 1):
         if algebraic_var is not None:
             algebraic_var[algebraic_var<=0.] = 0.
@@ -197,8 +197,8 @@
             ida.IDASetStopTime(self.ida_mem.obj, self.tcrit)
         else:
             if self.tcrit is not None:
-                raise ValueError, 'Cannot unset tcrit once set, take a large'\
-                        ' tcrit value instead.'
+                raise ValueError('Cannot unset tcrit once set, take a large'\
+                        ' tcrit value instead.')
     
     def set_init_val(self, y, yprime, t, res, jac=None):
         """IDA stores these and on a run the internal values are used
@@ -263,7 +263,7 @@
         else:
             #band jacobian
             if self.ml is None or self.mu is None:
-                raise ValueError, 'Give both uband and lband, or nothing'
+                raise ValueError('Give both uband and lband, or nothing')
             ida.IDABand(self.ida_mem.obj, n, self.mu, self.ml)
             if has_jac:
                 ida.IDABandSetJacFn(self.ida_mem.obj, self._jacBandFn, None)
@@ -339,16 +339,16 @@
                 ida.IDAGetConsistentIC(self.ida_mem.obj, corry, corryp)
                 return corry, corryp, t0
             else:
-                print("INFO IDA: Initial Condition calculated, continuing "
-                        "to time %g" % t1)
+                print(("INFO IDA: Initial Condition calculated, continuing "
+                        "to time %g" % t1))
         
         tret = ida.realtype(t0)
         
         try:
             ida.IDASolve(self.ida_mem.obj, t1, ctypes.byref(tret), 
                      self.__yret, self.__ypret, state)
-        except AssertionError, msg:
-            print msg
+        except AssertionError as msg:
+            print(msg)
             self.success = 0
             
         if self.printinfo:
@@ -382,12 +382,12 @@
             nje = ida.IDABandGetNumJacEvals(self.ida_mem.obj)
             nreLS = ida.IDABandGetNumResEvals(self.ida_mem.obj)
 
-        print "-----------------------------------------------------------"
-        print "Solve statistics: \n"
-        print "Number of steps										= %ld"%(nst)
-        print "Number of residual evaluations		 = %ld"%(nre+nreLS)
-        print "Number of Jacobian evaluations		 = %ld"%(nje)
-        print "Number of nonlinear iterations		 = %ld"%(nni)
-        print "Number of error test failures			= %ld"%(netf)
-        print "Number of nonlinear conv. failures = %ld"%(ncfn)
-        
+        print("-----------------------------------------------------------")
+        print("Solve statistics: \n")
+        print("Number of steps										= %ld"%(nst))
+        print("Number of residual evaluations		 = %ld"%(nre+nreLS))
+        print("Number of Jacobian evaluations		 = %ld"%(nje))
+        print("Number of nonlinear iterations		 = %ld"%(nni))
+        print("Number of error test failures			= %ld"%(netf))
+        print("Number of nonlinear conv. failures = %ld"%(ncfn))
+        

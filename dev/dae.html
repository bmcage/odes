
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>DAE Solvers &#8212; Odes 2.3.2.dev0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.3.2.dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Lower Level API" href="api.html" />
    <link rel="prev" title="ODE Solvers" href="ode.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="dae-solvers">
<h1>DAE Solvers<a class="headerlink" href="#dae-solvers" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="scikits.odes.dae.dae">
<em class="property">class </em><code class="descclassname">scikits.odes.dae.</code><code class="descname">dae</code><span class="sig-paren">(</span><em>integrator_name</em>, <em>eqsres</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scikits/odes/dae.html#dae"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scikits.odes.dae.dae" title="Permalink to this definition">¶</a></dt>
<dd><p>A generic interface class to differential algebraic equations.</p>
<p>Define equation res = G(t,y,y’) which can eg be G = f(y,t) - A y’ when solving A y’ = f(y,t), and where (optional) jac is the jacobian matrix of the nonlinear system see fortran source code), so d res/dy + scaling * d res/dy’ or d res/dy depending on the backend.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>integrator_name</strong> (<code class="docutils literal"><span class="pre">'ida'</span></code>, <code class="docutils literal"><span class="pre">'ddaspk'</span></code> or <code class="docutils literal"><span class="pre">'lsodi'</span></code>) – The integrator solver to use.</li>
<li><strong>eqsres</strong> (<em>residual function</em>) – <p>Residual of the DAE. The signature of this function depends on the
solver used, see the solver documentation for details.
Generally however, you can assume the following signature to work:</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">eqsres(x,</span> <span class="pre">y,</span> <span class="pre">yprime,</span> <span class="pre">return_residual)</span></code></div></blockquote>
<p>with
x       : independent variable, eg the time, float
y       : array of n unknowns in x
yprime  : dy/dx array of n unknowns in x, dimension = dim(y)
return_residual: array that must be updated with the value of the residuals, so G(t,y,y’).  The dimension is equal to dim(y)
return value: integer, 0 for success. It is not guaranteed that a solver takes this status into account</p>
<p>Some solvers will allow userdata to be passed to eqsres, or optional
formats that are more performant.</p>
</li>
<li><strong>options</strong> (<em>mapping</em>) – Additional options for initialization, solver dependent
See set_options method of the <cite>integrator_name</cite> you selected for
details.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-class docutils literal"><span class="pre">odeint</span></code></dt>
<dd>an ODE integrator with a simpler interface based on lsoda from ODEPACK</dd>
<dt><code class="xref py py-class docutils literal"><span class="pre">ode</span></code></dt>
<dd>class around vode ODE integrator</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Possible future solvers</p>
<p>ddaskr: Not included, starting hints: <a class="reference external" href="http://osdir.com/ml/python.f2py.user/2005-07/msg00014.html">http://osdir.com/ml/python.f2py.user/2005-07/msg00014.html</a>
Modified Extended Backward Differentiation Formulae (MEBDF): Not included. Fortran codes: <a class="reference external" href="http://www.ma.ic.ac.uk/~jcash/IVP_software/readme.html">http://www.ma.ic.ac.uk/~jcash/IVP_software/readme.html</a></p>
<p class="rubric">Examples</p>
<p>DAE arise in many applications of dynamical systems, as well as in
discritisations of PDE (eg moving mesh combined with method of
lines).
As an easy example, consider the simple oscillator, which we write as
G(y,y’,t) = 0 instead of the normal ode, and solve as a DAE.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="mf">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">initx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">initxp</span> <span class="o">=</span> <span class="p">[</span><span class="n">initx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">k</span><span class="o">/</span><span class="n">m</span><span class="o">*</span><span class="n">initx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">reseqn</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xdot</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
<span class="go">    ... # we create residual equations for the problem</span>
<span class="go">    ... result[0] = m*xdot[1] + k*x[0]</span>
<span class="go">    ... result[1] = xdot[0] - x[1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scikits.odes</span> <span class="k">import</span> <span class="n">dae</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span> <span class="o">=</span> <span class="n">dae</span><span class="p">(</span><span class="s1">&#39;ida&#39;</span><span class="p">,</span> <span class="n">reseqn</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="n">initx</span><span class="p">,</span> <span class="n">initxp</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="scikits.odes.dae.dae.init_step">
<code class="descname">init_step</code><span class="sig-paren">(</span><em>t0</em>, <em>y0</em>, <em>yp0</em>, <em>y_ic0_retn=None</em>, <em>yp_ic0_retn=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scikits/odes/dae.html#dae.init_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scikits.odes.dae.dae.init_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the solver and allocates memory. It is not needed to
call this method if solve is used to compute the solution. In the case
step is used, init_step must be called first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>- initial time</strong> (<em>t0</em>) – </li>
<li><strong>- initial condition for y</strong><strong> (</strong><strong>can be list</strong><strong> or </strong><strong>numpy array</strong><strong>)</strong> (<em>y0</em>) – </li>
<li><strong>- initial condition for yp</strong><strong> (</strong><strong>can be list</strong><strong> or </strong><strong>numpy array</strong><strong>)</strong> (<em>yp0</em>) – </li>
<li><strong>-</strong><strong> (</strong><strong>optional</strong><strong>) </strong><strong>returns the calculated consistent initial condition for y</strong> (<em>y_ic0</em>) – It MUST be a numpy array.</li>
<li><strong>-</strong><strong> (</strong><strong>optional</strong><strong>) </strong><strong>returns the calculated consistent initial</strong> (<em>yp_ic0</em>) – condition for y derivated. It MUST be a numpy array.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scikits.odes.dae.dae.set_options">
<code class="descname">set_options</code><span class="sig-paren">(</span><em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scikits/odes/dae.html#dae.set_options"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scikits.odes.dae.dae.set_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Set specific options for the solver.
See the solver documentation for details.</p>
<p>Calling set_options a second time, normally resets the solver.</p>
</dd></dl>

<dl class="method">
<dt id="scikits.odes.dae.dae.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>tspan</em>, <em>y0</em>, <em>yp0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scikits/odes/dae.html#dae.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scikits.odes.dae.dae.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the solver.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>tspan</strong> (<em>an list/array of times at which the computed value will be returned. Must contain the start time as first entry.</em>) – </li>
<li><strong>y0</strong> (<em>list/numpy array of initial values</em>) – </li>
<li><strong>yp0</strong> (<em>list/numpy array of initial values of derivatives</em>) – </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scikits.odes.dae.dae.step">
<code class="descname">step</code><span class="sig-paren">(</span><em>t</em>, <em>y_retn=None</em>, <em>yp_retn=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scikits/odes/dae.html#dae.step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scikits.odes.dae.dae.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for calling successive next step of the solver to allow
more precise control over the solver. The ‘init_step’ method has to
be called before the ‘step’ method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>t</strong> (<em>float</em>) – <p>A step is done towards time t, and output at t returned.
This time can be higher or lower than the previous time.
If option ‘one_step_compute’==True, and the solver supports
it, only one internal solver step is done in the direction
of t starting at the current step.</p>
<dl class="docutils">
<dt>If old_api=True, the old behavior is used:</dt>
<dd><ul class="first last">
<li>if t&gt;0.0 then integration is performed until this time and results at this time are returned in y_retn</li>
<li>if t&lt;0.0 only one internal step is perfomed towards time abs(t) and results after this one time step are returned</li>
</ul>
</dd>
</dl>
</li>
<li><strong>y_retn</strong> (<em>numpy array</em><em> (</em><em>ndim = 1</em><em>) or </em><em>None</em>) – array in which the computed value will be stored (needs to be preallocated). If None y_retn is not used.</li>
<li><strong>yp_retn</strong> (<em>numpy vector</em><em> (</em><em>ndim = 1</em><em>) or </em><em>None</em>) – If not None, will be filled (needs to be preallocated) with derivatives of y at time t. If None yp_retn is not used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="ode.html" title="previous chapter">ODE Solvers</a></li>
      <li>Next: <a href="api.html" title="next chapter">Lower Level API</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/dae.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, B. Malengier.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/dae.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>
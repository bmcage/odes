<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>DAE Solvers &#8212; Odes 3.0.0+13.g5c9ff97 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <link rel="stylesheet" type="text/css" href="_static/badge_only.css?v=cf56f567" />
    <script src="_static/jquery.js?v=5d32c60e"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="_static/documentation_options.js?v=9e513fa5"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/docs-versions-menu.js?v=45d24689"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Sundials Solver Options" href="sundials.html" />
    <link rel="prev" title="ODE Solvers" href="ode.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="dae-solvers">
<h1>DAE Solvers<a class="headerlink" href="#dae-solvers" title="Link to this heading">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="scikits.odes.dae.dae">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">scikits.odes.dae.</span></span><span class="sig-name descname"><span class="pre">dae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">integrator_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eqsres</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scikits_odes/dae.html#dae"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scikits.odes.dae.dae" title="Link to this definition">¶</a></dt>
<dd><p>A generic interface class to differential algebraic equations.</p>
<p>Define equation res = G(t,y,y’) which can eg be G = f(y,t) - A y’ when
solving A y’ = f(y,t), and where (optional) jac is the jacobian matrix of
the nonlinear system see fortran source code), so d res/dy + scaling * d
res/dy’ or d res/dy depending on the backend.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>integrator_name</strong> (<code class="docutils literal notranslate"><span class="pre">'ida'</span></code>, <code class="docutils literal notranslate"><span class="pre">'ddaspk'</span></code> or <code class="docutils literal notranslate"><span class="pre">'lsodi'</span></code>) – The integrator solver to use.</p></li>
<li><p><strong>eqsres</strong> (<em>residual function</em>) – <p>Residual of the DAE. The signature of this function depends on the
solver used, see the solver documentation for details.
Generally however, you can assume the following signature to work:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">eqsres(x,</span> <span class="pre">y,</span> <span class="pre">yprime,</span> <span class="pre">return_residual)</span></code></p>
</div></blockquote>
<p>with
x       : independent variable, eg the time, float
y       : array of n unknowns in x
yprime  : dy/dx array of n unknowns in x, dimension = dim(y)
return_residual: array that must be updated with the value of the residuals, so G(t,y,y’).  The dimension is equal to dim(y)
return value: integer, 0 for success. It is not guaranteed that a solver takes this status into account</p>
<p>Some solvers will allow userdata to be passed to eqsres, or optional
formats that are more performant.</p>
</p></li>
<li><p><strong>options</strong> (<em>mapping</em>) – Additional options for initialization, solver dependent
See set_options method of the <cite>integrator_name</cite> you selected for
details.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">odeint</span></code></dt><dd><p>an ODE integrator with a simpler interface based on lsoda from ODEPACK</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ode</span></code></dt><dd><p>class around vode ODE integrator</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Possible future solvers</p>
<p>ddaskr: Not included, starting hints:
<a class="reference external" href="http://osdir.com/ml/python.f2py.user/2005-07/msg00014.html">http://osdir.com/ml/python.f2py.user/2005-07/msg00014.html</a>
Modified Extended Backward Differentiation Formulae (MEBDF): Not included.
Fortran codes: <a class="reference external" href="http://www.ma.ic.ac.uk/~jcash/IVP_software/readme.html">http://www.ma.ic.ac.uk/~jcash/IVP_software/readme.html</a></p>
<p class="rubric">Examples</p>
<p>DAE arise in many applications of dynamical systems, as well as in
discritisations of PDE (eg moving mesh combined with method of
lines).
As an easy example, consider the simple oscillator, which we write as
G(y,y’,t) = 0 instead of the normal ode, and solve as a DAE.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="mf">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">initx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">initxp</span> <span class="o">=</span> <span class="p">[</span><span class="n">initx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">k</span><span class="o">/</span><span class="n">m</span><span class="o">*</span><span class="n">initx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">reseqn</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xdot</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
<span class="go">    ... # we create residual equations for the problem</span>
<span class="go">    ... result[0] = m*xdot[1] + k*x[0]</span>
<span class="go">    ... result[1] = xdot[0] - x[1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scikits.odes</span> <span class="kn">import</span> <span class="n">dae</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span> <span class="o">=</span> <span class="n">dae</span><span class="p">(</span><span class="s1">&#39;ida&#39;</span><span class="p">,</span> <span class="n">reseqn</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="n">initx</span><span class="p">,</span> <span class="n">initxp</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="scikits.odes.dae.dae.init_step">
<span class="sig-name descname"><span class="pre">init_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yp0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_ic0_retn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yp_ic0_retn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scikits_odes/dae.html#dae.init_step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scikits.odes.dae.dae.init_step" title="Link to this definition">¶</a></dt>
<dd><p>Initializes the solver and allocates memory. It is not needed to
call this method if solve is used to compute the solution. In the case
step is used, init_step must be called first.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t0</strong> (<em>number</em>) – initial time</p></li>
<li><p><strong>y0</strong> (<em>list/array</em>) – initial condition for y</p></li>
<li><p><strong>yp0</strong> (<em>list/array</em>) – initial condition for yp</p></li>
<li><p><strong>y_ic0</strong> (<em>numpy array</em>) – (optional) returns the calculated consistent initial condition for y</p></li>
<li><p><strong>yp_ic0</strong> (<em>numpy array</em>) – (optional) returns the calculated consistent initial condition for y
derivated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul>
<li><p><strong>old_api is False</strong> (<em>namedtuple</em>) – namedtuple with the following attributes</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">flag</span></code></p></td>
<td><p>An integer flag (StatusEnumXXX)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">values</span></code></p></td>
<td><p>Named tuple with entries t and y and ydot. y will correspond to y_retn value and ydot to yp_retn!</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">errors</span></code></p></td>
<td><p>Named tuple with entries t and y and ydot</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">roots</span></code></p></td>
<td><p>Named tuple with entries t and y and ydot</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">tstop</span></code></p></td>
<td><p>Named tuple with entries t and y and ydot</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">message</span></code></p></td>
<td><p>String with message in case of an error</p></td>
</tr>
</tbody>
</table>
</li>
<li><p><strong>old_api is True</strong> (<em>tuple</em>) – tuple with the following elements in order</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">flag</span></code></p></td>
<td><p>status of the computation (successful or error occurred)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">t_out</span></code></p></td>
<td><p>time, where the solver stopped (when no error occurred, t_out == t)</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scikits.odes.dae.dae.set_options">
<span class="sig-name descname"><span class="pre">set_options</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scikits_odes/dae.html#dae.set_options"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scikits.odes.dae.dae.set_options" title="Link to this definition">¶</a></dt>
<dd><p>Set specific options for the solver.
See the solver documentation for details.</p>
<p>Calling set_options a second time, normally resets the solver.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scikits.odes.dae.dae.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tspan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yp0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scikits_odes/dae.html#dae.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scikits.odes.dae.dae.solve" title="Link to this definition">¶</a></dt>
<dd><p>Runs the solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tspan</strong> (<em>list/array</em>) – A list of times at which the computed value will be returned. Must
contain the start time as first entry.</p></li>
<li><p><strong>y0</strong> (<em>list/array</em>) – list array of initial values</p></li>
<li><p><strong>yp0</strong> (<em>list/array</em>) – list array of initial values of derivatives</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul>
<li><p><strong>old_api is False</strong> (<em>namedtuple</em>) – namedtuple with the following attributes</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">flag</span></code></p></td>
<td><p>An integer flag (StatusEnumXXX)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">values</span></code></p></td>
<td><p>Named tuple with entries array t and array y and array ydot. y will correspond to y_retn value and ydot to yp_retn!</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">errors</span></code></p></td>
<td><p>Named tuple with entries t and y and ydot of error</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">roots</span></code></p></td>
<td><p>Named tuple with entries array t and array y and array ydot</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">tstop</span></code></p></td>
<td><p>Named tuple with entries array t and array y and array ydot</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">message</span></code></p></td>
<td><p>String with message in case of an error</p></td>
</tr>
</tbody>
</table>
</li>
<li><p><strong>old_api is True</strong> (<em>tuple</em>) – tuple with the following elements in order</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">flag</span></code></p></td>
<td><p>indicating return status of the solver</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">t</span></code></p></td>
<td><p>numpy array of times at which the computations were successful</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">y</span></code></p></td>
<td><p>numpy array of values corresponding to times t (values of y[i, :] ~ t[i])</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">yp</span></code></p></td>
<td><p>numpy array of derivatives corresponding to times t (values of yp[i, :] ~ t[i])</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">t_err</span></code></p></td>
<td><p>float or None - if recoverable error occurred (for example reached maximum number of allowed iterations), this is the time at which it happened</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">y_err</span></code></p></td>
<td><p>numpy array of values corresponding to time t_err</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">yp_err</span></code></p></td>
<td><p>numpy array of derivatives corresponding to time t_err</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scikits.odes.dae.dae.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_retn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yp_retn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scikits_odes/dae.html#dae.step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scikits.odes.dae.dae.step" title="Link to this definition">¶</a></dt>
<dd><p>Method for calling successive next step of the IDA solver to allow
more precise control over the IDA solver. The ‘init_step’ method has to
be called before the ‘step’ method.</p>
<p>A step is done towards time t, and output at t returned. This time can
be higher or lower than the previous time. If option
‘one_step_compute’==True, and the solver supports it, only one internal
solver step is done in the direction of t starting at the current step.</p>
<p>If old_api=True, the old behavior is used: if t&gt;0.0 then integration is
performed until this time and results at this time are returned in
y_retn; else if if t&lt;0.0 only one internal step is performed towards time
abs(t) and results after this one time step are returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>number</em>)</p></li>
<li><p><strong>y_retn</strong> (<em>numpy array</em><em> (</em><em>ndim = 1</em><em>) or </em><em>None.</em>) – (Needs to be preallocated) If not None, will be filled with y at
time t. If None y_retn is not used.</p></li>
<li><p><strong>yp_retn</strong> (<em>numpy array</em><em> (</em><em>ndim = 1</em><em>) or </em><em>None.</em>) – (Needs to be preallocated) If not None, will be filled with
derivatives of y at time t. If None yp_retn is not used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul>
<li><p><strong>old_api is False</strong> (<em>namedtuple</em>) – namedtuple with the following attributes</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">flag</span></code></p></td>
<td><p>An integer flag (StatusEnumXXX)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">values</span></code></p></td>
<td><p>Named tuple with entries t and y and ydot. y will correspond to y_retn value and ydot to yp_retn!</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">errors</span></code></p></td>
<td><p>Named tuple with entries t and y and ydot</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">roots</span></code></p></td>
<td><p>Named tuple with entries t and y and ydot</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">tstop</span></code></p></td>
<td><p>Named tuple with entries t and y and ydot</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">message</span></code></p></td>
<td><p>String with message in case of an error</p></td>
</tr>
</tbody>
</table>
</li>
<li><p><strong>old_api is True</strong> (<em>tuple</em>) – tuple with the following elements in order</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">flag</span></code></p></td>
<td><p>status of the computation (successful or error occurred)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">t_out</span></code></p></td>
<td><p>time, where the solver stopped (when no error occurred, t_out == t)</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Odes</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ode.html">ODE Solvers</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">DAE Solvers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#scikits.odes.dae.dae"><code class="docutils literal notranslate"><span class="pre">dae</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#scikits.odes.dae.dae.init_step"><code class="docutils literal notranslate"><span class="pre">dae.init_step()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#scikits.odes.dae.dae.set_options"><code class="docutils literal notranslate"><span class="pre">dae.set_options()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#scikits.odes.dae.dae.solve"><code class="docutils literal notranslate"><span class="pre">dae.solve()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#scikits.odes.dae.dae.step"><code class="docutils literal notranslate"><span class="pre">dae.step()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="sundials.html">Sundials Solver Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="api/index.html">Lower Level API</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="ode.html" title="previous chapter">ODE Solvers</a></li>
      <li>Next: <a href="sundials.html" title="next chapter">Sundials Solver Options</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2016, B. Malengier.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/dae.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>
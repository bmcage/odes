<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>ODE Solvers &#8212; Odes 3.0.0+16.g34641c8 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <link rel="stylesheet" type="text/css" href="_static/badge_only.css?v=cf56f567" />
    <script src="_static/jquery.js?v=5d32c60e"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="_static/documentation_options.js?v=9852645b"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/docs-versions-menu.js?v=45d24689"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="DAE Solvers" href="dae.html" />
    <link rel="prev" title="Welcome to the ODES scikit API Documentation" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="ode-solvers">
<h1>ODE Solvers<a class="headerlink" href="#ode-solvers" title="Link to this heading">¶</a></h1>
<p><a class="reference internal" href="api/compat.html#module-scikits.odes" title="scikits.odes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scikits.odes</span></code></a> contains two main routines for solving ODEs: the simpler
<a class="reference internal" href="#scikits.odes.odeint.odeint" title="scikits.odes.odeint.odeint"><code class="xref py py-func docutils literal notranslate"><span class="pre">scikits.odes.odeint.odeint()</span></code></a>, and the more configurable
<a class="reference internal" href="#scikits.odes.ode.ode" title="scikits.odes.ode.ode"><code class="xref py py-class docutils literal notranslate"><span class="pre">scikits.odes.ode.ode</span></code></a>. Both these routines allow selection of the
solver and solution method used. Additionally, it is also possible to directly
use the low level interface to individual solvers.</p>
<dl class="py function">
<dt class="sig sig-object py" id="scikits.odes.odeint.odeint">
<span class="sig-prename descclassname"><span class="pre">scikits.odes.odeint.</span></span><span class="sig-name descname"><span class="pre">odeint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rhsfun</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tout</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'bdf'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scikits_odes/odeint.html#odeint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scikits.odes.odeint.odeint" title="Link to this definition">¶</a></dt>
<dd><p>Integrate a system of ordinary differential equations.
<em>odeint</em> is a wrapper around the ode class, as a convenience function to
quickly integrate a system of ode.
Solves the initial value problem for stiff or non-stiff systems
of first order ode’s:</p>
<blockquote>
<div><p>rhs = dy/dt = fun(t, y)</p>
</div></blockquote>
<p>where y can be a vector, then rhsfun must be a function computing rhs with
signature:</p>
<blockquote>
<div><p>rhsfun(t, y, rhs)</p>
</div></blockquote>
<p>storing the computed dy/dt in the rhs array passed to the function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rhsfun</strong> (<em>callable</em><em>(</em><em>t</em><em>, </em><em>y</em><em>, </em><em>out</em><em>)</em>) – Computes the derivative at dy/dt in terms of t and y, and stores in out</p></li>
<li><p><strong>y0</strong> (<em>array</em>) – Initial condition on y (can be a vector).</p></li>
<li><p><strong>t</strong> (<em>array</em>) – A sequence of time points for which to solve for y.  The initial
value point should be the first element of this sequence.</p></li>
<li><p><strong>method</strong> (<em>string</em><em>, </em><em>solution method to use.</em>) – <p>Available are all the ode class solvers as well as some convenience
shorthands:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bdf</p></td>
<td><p>This uses the ‘cvode’ solver in default from, which is a
variable step, variable coefficient Backward Differentiation
Formula solver, good for stiff ODE. Newton iterations are
used to solve the nonlinear system.</p></td>
</tr>
<tr class="row-odd"><td><p>admo</p></td>
<td><p>This uses the ‘cvode’ solver with option lmm_type=’ADAMS’,
which is a variable step Adams-Moulton method (linear
multistep method), good for non-stiff ODE. Functional
iterations are used to solve the nonlinear system.</p></td>
</tr>
<tr class="row-even"><td><p>rk5</p></td>
<td><p>This uses the ‘dopri5’ solver, which is a variable step
Runge-Kutta method of order (4)5 (use for non-stiff ODE)</p></td>
</tr>
<tr class="row-odd"><td><p>rk8</p></td>
<td><p>This uses the ‘dop853’ solver, which is a variable step
Runge-Kutta method of order 8(5,3)</p></td>
</tr>
</tbody>
</table>
<p>For educational purposes, you can also access following methods:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>beuler</p></td>
<td><p>This is the Implicit Euler (backward Euler) method (order 1),
which is obtained via the ‘bdf’ method, setting the order
option to 1, setting large tolerances,  and fixing the
stepsize.
Use option ‘step’ to change stepsize, default: step=0.05.
Use option ‘rtol’ and ‘atol’ to use more strict tolerances
Note: this is not completely the backward Euler method, as
the cvode solver has added control options!</p></td>
</tr>
<tr class="row-odd"><td><p>trapz</p></td>
<td><p>This is the Trapezoidal Rule method (order 2), which is
obtained via the ‘admo’ method, setting option order to 2,
setting large tolerances and fixing the stepsize.
Use option ‘step’ to change stepsize, default: step=0.05.
Use option ‘rtol’ and ‘atol’ to use more strict tolerances
Note: The cvode solver might change the order to 1 internally
in which case this becomes beuler method. Set atol, rtol
options as strict as possible.</p></td>
</tr>
</tbody>
</table>
<p>You can also access the solvers of ode via their names:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>cvode</p></td>
<td><p>This uses the ‘cvode’ solver</p></td>
</tr>
<tr class="row-odd"><td><p>dopri5</p></td>
<td><p>This uses the ‘dopri5’ solver</p></td>
</tr>
<tr class="row-even"><td><p>dop853</p></td>
<td><p>This uses the ‘dop853’ solver</p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>options</strong> (<em>extra solver options</em><em>, </em><em>optional</em>) – Every solver has it’s own extra options, see the ode class and the
details of the solvers available there to know the options possible per
solver</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>solution</strong> – A single named tuple is returned containing the result of the
integration.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>flag</p></td>
<td><p>An integer flag</p></td>
</tr>
<tr class="row-odd"><td><p>values</p></td>
<td><p>Named tuple with fields t and y</p></td>
</tr>
<tr class="row-even"><td><p>errors</p></td>
<td><p>Named tuple with fields t and y</p></td>
</tr>
<tr class="row-odd"><td><p>roots</p></td>
<td><p>Named tuple with fields t and y</p></td>
</tr>
<tr class="row-even"><td><p>tstop</p></td>
<td><p>Named tuple with fields t and y</p></td>
</tr>
<tr class="row-odd"><td><p>message</p></td>
<td><p>String with message in case of an error</p></td>
</tr>
</tbody>
</table>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>named tuple</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#scikits.odes.ode.ode" title="scikits.odes.ode.ode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scikits.odes.ode.ode</span></code></a></dt><dd><p>a more object-oriented integrator</p>
</dd>
<dt><a class="reference internal" href="dae.html#scikits.odes.dae.dae" title="scikits.odes.dae.dae"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scikits.odes.dae.dae</span></code></a></dt><dd><p>a solver for differential-algebraic equations</p>
</dd>
<dt><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad" title="(in SciPy v1.14.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.integrate.quad</span></code></a></dt><dd><p>for finding the area under a curve</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>The second order differential equation for the angle <cite>theta</cite> of a
pendulum acted on by gravity with friction can be written:</p>
<div class="math notranslate nohighlight">
\[\theta''(t) + b \theta'(t) + c \sin(\theta(t)) = 0\]</div>
<p>where <cite>b</cite> and <cite>c</cite> are positive constants, and a prime (’) denotes a
derivative.  To solve this equation with <cite>odeint</cite>, we must first convert
it to a system of first order equations.  By defining the angular
velocity <code class="docutils literal notranslate"><span class="pre">omega(t)</span> <span class="pre">=</span> <span class="pre">theta'(t)</span></code>, we obtain the system:</p>
<div class="math notranslate nohighlight">
\[\theta'(t) = \omega(t)
\omega'(t) = -b \omega(t) - c \sin(\theta(t))\]</div>
<p>We assume the constants are <cite>b</cite> = 0.25 and <cite>c</cite> = 5.0:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mf">0.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="mf">5.0</span>
</pre></div>
</div>
<p>Let <cite>y</cite> be the vector [<cite>theta</cite>, <cite>omega</cite>].  We implement this system
in python as:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">pend</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
<span class="go"> ...     theta, omega = y</span>
<span class="go"> ...     out[:] = [omega, -b*omega - c*np.sin(theta)]</span>
<span class="go"> ...</span>
</pre></div>
</div>
<p>In case you want b and c easily changable, make pend a class method, and
consider attributes b and c accessible via <cite>self.b</cite> and <cite>self.c</cite>.
For initial conditions, we assume the pendulum is nearly vertical
with <cite>theta(0)</cite> = <cite>pi</cite> - 0.1, and it initially at rest, so
<cite>omega(0)</cite> = 0.  Then the vector of initial conditions is</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y0</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
</pre></div>
</div>
<p>We generate a solution 101 evenly spaced samples in the interval
0 &lt;= <cite>t</cite> &lt;= 10.  So our array of times is</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
</pre></div>
</div>
<p>Call <cite>odeint</cite> to generate the solution.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scikits.odes.odeint</span> <span class="kn">import</span> <span class="n">odeint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">pend</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span>
</pre></div>
</div>
<p>The solution is a named tuple <cite>sol</cite>. sol.values.y is an array with shape (101, 2).
The first column is <cite>theta(t)</cite>, and the second is <cite>omega(t)</cite>.
The following code plots both components.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">sol</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">y</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;theta(t)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">sol</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">y</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;omega(t)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="scikits.odes.ode.ode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">scikits.odes.ode.</span></span><span class="sig-name descname"><span class="pre">ode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">integrator_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eqsrhs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scikits_odes/ode.html#ode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scikits.odes.ode.ode" title="Link to this definition">¶</a></dt>
<dd><p>A generic interface class to differential equation solvers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>integrator_name</strong> (<code class="docutils literal notranslate"><span class="pre">'cvode'</span></code>, <code class="docutils literal notranslate"><span class="pre">'dopri5'</span></code> or <code class="docutils literal notranslate"><span class="pre">'dop853'</span></code>) – <p>The solver to use.</p>
<p><code class="docutils literal notranslate"><span class="pre">'cvode'</span></code> selects the CVODE solver from the SUNDIALS package.
See py:class:<cite>scikits.odes.sundials.cvode.CVODE</cite> for solver specific
options.</p>
<p><code class="docutils literal notranslate"><span class="pre">'dopri5'</span></code> selects the Dormand &amp; Prince Runge-Kutta order (4)5
solver from scipy.</p>
</p></li>
<li><p><strong>eqsrhs</strong> (<em>right-hand-side function</em>) – <p>Right-hand-side of a first order ode.
Generally, you can assume the following signature to work:</p>
<blockquote>
<div><p>eqsrhs(x, y, return_rhs)</p>
</div></blockquote>
<p>with</p>
<blockquote>
<div><p>x: independent variable, eg the time, float</p>
<p>y: array of n unknowns in x</p>
<p>return_rhs : array that must be updated with the value of the
right-hand-side, so f(t,y).  The dimension is equal to
dim(y)</p>
</div></blockquote>
<dl class="simple">
<dt>return value: An integer, 0 for success, 1 for failure.</dt><dd><p>It is not guaranteed that a solver takes this status into account</p>
</dd>
</dl>
<p>Some solvers will allow userdata to be passed to eqsrhs, or optional
formats that are more performant.</p>
</p></li>
<li><p><strong>options</strong> (<em>additional options</em><em> of </em><em>the solver</em>) – See set_options method of the <cite>integrator_name</cite> you selected for
details.
Set option <cite>old_api=False</cite> to use the new API. In the future, this
will become the default!</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#scikits.odes.odeint.odeint" title="scikits.odes.odeint.odeint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scikits.odes.odeint.odeint</span></code></a></dt><dd><p>an ODE integrator with a simpler interface</p>
</dd>
<dt><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/integrate.html#module-scipy.integrate" title="(in SciPy v1.14.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.integrate</span></code></a></dt><dd><p>Methods in scipy for ODE integration</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>ODE arise in many applications of dynamical systems, as well as in
discritisations of PDE (eg moving mesh combined with method of
lines).
As an easy example, consider the simple oscillator,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="mf">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">initx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">rhseqn</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xdot</span><span class="p">):</span>
<span class="go">        # we create rhs equations for the problem</span>
<span class="go">        xdot[0] = x[1]</span>
<span class="go">        xdot[1] = - k/m * x[0]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scikits.odes</span> <span class="kn">import</span> <span class="n">ode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span> <span class="o">=</span> <span class="n">ode</span><span class="p">(</span><span class="s1">&#39;cvode&#39;</span><span class="p">,</span> <span class="n">rhseqn</span><span class="p">,</span> <span class="n">old_api</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="n">initx</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   t        Solution          Exact&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;------------------------------------&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">y</span><span class="p">):</span>
<span class="go">        print(&#39;%4.2f %15.6g %15.6g&#39; % (t, u[0], initx[0]*cos(sqrt(k/m)*t)+initx[1]*sin(sqrt(k/m)*t)/sqrt(k/m)))</span>
</pre></div>
</div>
<p>More examples in the <a class="reference external" href="https://github.com/bmcage/odes/tree/master/docs/src/examples">Examples</a> directory and <a class="reference external" href="https://github.com/bmcage/odes/tree/master/docs/ipython">IPython</a> worksheets.</p>
<dl class="py method">
<dt class="sig sig-object py" id="scikits.odes.ode.ode.get_info">
<span class="sig-name descname"><span class="pre">get_info</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/scikits_odes/ode.html#ode.get_info"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scikits.odes.ode.ode.get_info" title="Link to this definition">¶</a></dt>
<dd><p>Return additional information about the state of the integrator.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>A dictionary filled with internal data as exposed by the integrator.</em></p></li>
<li><p>See the <cite>get_info</cite> method of your chosen integrator for details.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scikits.odes.ode.ode.init_step">
<span class="sig-name descname"><span class="pre">init_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scikits_odes/ode.html#ode.init_step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scikits.odes.ode.ode.init_step" title="Link to this definition">¶</a></dt>
<dd><p>Initializes the solver and allocates memory. It is not needed to
call this method if solve is used to compute the solution. In the case
step is used, init_step must be called first.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t0</strong> (<em>number</em>) – initial time</p></li>
<li><p><strong>y0</strong> (<em>array</em>) – initial condition for y (can be list or numpy array)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul>
<li><p><strong>old_api is False</strong> (<em>namedtuple</em>) – namedtuple with the following attributes</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">flag</span></code></p></td>
<td><p>An integer flag (StatusEnum)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">values</span></code></p></td>
<td><p>Named tuple with entries t and y</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">errors</span></code></p></td>
<td><p>Named tuple with entries t and y</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">roots</span></code></p></td>
<td><p>Named tuple with entries t and y</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">tstop</span></code></p></td>
<td><p>Named tuple with entries t and y</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">message</span></code></p></td>
<td><p>String with message in case of an error</p></td>
</tr>
</tbody>
</table>
</li>
<li><p><strong>old_api is True</strong> (<em>tuple</em>) – tuple with the following elements in order</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">flag</span></code></p></td>
<td><p>boolean status of the computation (successful or error occured)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">t_out</span></code></p></td>
<td><p>inititial time</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scikits.odes.ode.ode.set_options">
<span class="sig-name descname"><span class="pre">set_options</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scikits_odes/ode.html#ode.set_options"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scikits.odes.ode.ode.set_options" title="Link to this definition">¶</a></dt>
<dd><p>Set specific options for the solver.
See the solver documentation for details.</p>
<p>Calling set_options a second time, is only possible for options that
can change during runtime.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scikits.odes.ode.ode.set_tstop">
<span class="sig-name descname"><span class="pre">set_tstop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tstop</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scikits_odes/ode.html#ode.set_tstop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scikits.odes.ode.ode.set_tstop" title="Link to this definition">¶</a></dt>
<dd><p>Add a stop time to the integrator past which he is not allowed to
integrate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>tstop</strong> (<em>float time</em>) – Time point in the future where the integration must stop. You can
indicate like this that integration past this point is not allowed,
in order to avoid undefined behavior.
You can achieve the same result with a call to
<cite>set_options(tstop=tstop)</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scikits.odes.ode.ode.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tspan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scikits_odes/ode.html#ode.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scikits.odes.ode.ode.solve" title="Link to this definition">¶</a></dt>
<dd><p>Runs the solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tspan</strong> (<em>array</em><em> (or </em><em>similar</em><em>)</em>) – a list of times at which the computed value will be returned. Must
contain the start time as first entry.</p></li>
<li><p><strong>y0</strong> (<em>array</em><em> (or </em><em>similar</em><em>)</em>) – a list of initial values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul>
<li><p><strong>old_api is False</strong> (<em>namedtuple</em>) – namedtuple with the following attributes</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">flag</span></code></p></td>
<td><p>An integer flag (StatusEnum)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">values</span></code></p></td>
<td><p>Named tuple with entries t and y</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">errors</span></code></p></td>
<td><p>Named tuple with entries t and y</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">roots</span></code></p></td>
<td><p>Named tuple with entries t and y</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">tstop</span></code></p></td>
<td><p>Named tuple with entries t and y</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">message</span></code></p></td>
<td><p>String with message in case of an error</p></td>
</tr>
</tbody>
</table>
</li>
<li><p><strong>old_api is True</strong> (<em>tuple</em>) – tuple with the following elements in order</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">flag</span></code></p></td>
<td><p>indicating return status of the solver</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">t</span></code></p></td>
<td><p>numpy array of times at which the computations were successful</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">y</span></code></p></td>
<td><p>numpy array of values corresponding to times t (values of y[i, :] ~ t[i])</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">t_err</span></code></p></td>
<td><p>float or None - if recoverable error occured (for example reached maximum number of allowed iterations), this is the time at which it happened</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">y_err</span></code></p></td>
<td><p>numpy array of values corresponding to time t_err</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scikits.odes.ode.ode.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_retn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scikits_odes/ode.html#ode.step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scikits.odes.ode.ode.step" title="Link to this definition">¶</a></dt>
<dd><p>Method for calling successive next step of the ODE solver to allow
more precise control over the solver. The ‘init_step’ method has to
be called before the ‘step’ method.</p>
<p>A step is done towards time t, and output at t returned.  This time can
be higher or lower than the previous time.  If option
‘one_step_compute’==True, and the solver supports it, only one internal
solver step is done in the direction of t starting at the current step.</p>
<p>If old_api=True, the old behavior is used: if t&gt;0.0 then integration is
performed until this time and results at this time are returned in
y_retn if t&lt;0.0 only one internal step is perfomed towards time abs(t)
and results after this one time step are returned</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>number</em>)</p></li>
<li><p><strong>y_retn</strong> (<em>numpy vector</em><em> (</em><em>ndim = 1</em><em>)</em>) – in which the computed value will be stored  (needs to be
preallocated).  If None y_retn is not used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul>
<li><p><strong>old_api is False</strong> (<em>namedtuple</em>) – namedtuple with the following attributes</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">flag</span></code></p></td>
<td><p>An integer flag (StatusEnum)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">values</span></code></p></td>
<td><p>Named tuple with entries t and y</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">errors</span></code></p></td>
<td><p>Named tuple with entries t and y</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">roots</span></code></p></td>
<td><p>Named tuple with entries t and y</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">tstop</span></code></p></td>
<td><p>Named tuple with entries t and y</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">message</span></code></p></td>
<td><p>String with message in case of an error</p></td>
</tr>
</tbody>
</table>
</li>
<li><p><strong>old_api is True</strong> (<em>tuple</em>) – tuple with the following elements in order</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">flag</span></code></p></td>
<td><p>status of the computation (successful or error occured)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">t_out</span></code></p></td>
<td><p>time, where the solver stopped (when no error occured, t_out == t)</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Odes</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">ODE Solvers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#scikits.odes.odeint.odeint"><code class="docutils literal notranslate"><span class="pre">odeint()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#scikits.odes.ode.ode"><code class="docutils literal notranslate"><span class="pre">ode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#scikits.odes.ode.ode.get_info"><code class="docutils literal notranslate"><span class="pre">ode.get_info()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#scikits.odes.ode.ode.init_step"><code class="docutils literal notranslate"><span class="pre">ode.init_step()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#scikits.odes.ode.ode.set_options"><code class="docutils literal notranslate"><span class="pre">ode.set_options()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#scikits.odes.ode.ode.set_tstop"><code class="docutils literal notranslate"><span class="pre">ode.set_tstop()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#scikits.odes.ode.ode.solve"><code class="docutils literal notranslate"><span class="pre">ode.solve()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#scikits.odes.ode.ode.step"><code class="docutils literal notranslate"><span class="pre">ode.step()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="dae.html">DAE Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="sundials.html">Sundials Solver Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="api/index.html">Lower Level API</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to the ODES scikit API Documentation</a></li>
      <li>Next: <a href="dae.html" title="next chapter">DAE Solvers</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2016, B. Malengier.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/ode.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>